{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nexports.__esModule = true;\nexports.fetchEmojis = exports.embedEmojis = exports.default = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _emojiRegex = _interopRequireDefault(require(\"emoji-regex\"));\nvar _image = _interopRequireDefault(require(\"@react-pdf/image\"));\n\n/* eslint-disable no-cond-assign */\n// Caches emoji images data\nvar emojis = {};\nvar regex = (0, _emojiRegex.default)();\nvar reflect = function reflect(promise) {\n  return function () {\n    return promise.apply(void 0, arguments).then(function (v) {\n      return v;\n    }, function (e) {\n      return e;\n    });\n  };\n}; // Returns a function to be able to mock resolveImage.\n\nvar makeFetchEmojiImage = function makeFetchEmojiImage() {\n  return reflect(_image.default);\n};\n/**\n * When an emoji as no color, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('‚ù§Ô∏è') => [\"‚ù§\", \"Ô∏è\"]\n *   (w/ color) Array.from('üëçüèø') => [\"üëç\", \"üèø\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\n\nvar _removeNoColor = function _removeNoColor(x) {\n  return x !== 'Ô∏è';\n};\nvar getCodePoints = function getCodePoints(string) {\n  return Array.from(string).filter(_removeNoColor).map(function (char) {\n    return char.codePointAt(0).toString(16);\n  }).join('-');\n};\nvar buildEmojiUrl = function buildEmojiUrl(emoji, source) {\n  var url = source.url,\n    format = source.format;\n  return \"\" + url + getCodePoints(emoji) + \".\" + format;\n};\nvar fetchEmojis = function fetchEmojis(string, source) {\n  if (!source || !source.url) return [];\n  var promises = [];\n  var match;\n  var _loop = function _loop() {\n    var emoji = match[0];\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      var emojiUrl = buildEmojiUrl(emoji, source);\n      emojis[emoji] = {\n        loading: true\n      };\n      var fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(fetchEmojiImage({\n        uri: emojiUrl\n      }).then(function (image) {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  };\n  while (match = regex.exec(string)) {\n    _loop();\n  }\n  return promises;\n};\nexports.fetchEmojis = fetchEmojis;\nvar embedEmojis = function embedEmojis(fragments) {\n  var result = [];\n  for (var i = 0; i < fragments.length; i += 1) {\n    var fragment = fragments[i];\n    var match = void 0;\n    var lastIndex = 0;\n    while (match = regex.exec(fragment.string)) {\n      var _match = match,\n        index = _match.index;\n      var emoji = match[0];\n      var emojiSize = fragment.attributes.fontSize;\n      var chunk = fragment.string.slice(lastIndex, index + match[0].length); // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: (0, _extends2.default)({}, fragment.attributes, {\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          })\n        });\n      } else {\n        // If no emoji data, we just replace the emoji with a nodef char\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0)),\n          attributes: fragment.attributes\n        });\n      }\n      lastIndex = index + emoji.length;\n    }\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n  return result;\n};\nexports.embedEmojis = embedEmojis;\nvar _default = fetchEmojis;\nexports.default = _default;","map":{"version":3,"names":["_interopRequireDefault","require","default","exports","__esModule","fetchEmojis","embedEmojis","_extends2","_emojiRegex","_image","emojis","regex","reflect","promise","apply","arguments","then","v","e","makeFetchEmojiImage","_removeNoColor","x","getCodePoints","string","Array","from","filter","map","char","codePointAt","toString","join","buildEmojiUrl","emoji","source","url","format","promises","match","_loop","loading","emojiUrl","fetchEmojiImage","push","uri","image","data","exec","fragments","result","i","length","fragment","lastIndex","_match","index","emojiSize","attributes","fontSize","chunk","slice","replace","String","fromCharCode","attachment","width","height","yOffset","Math","floor","_default"],"sources":["C:/Users/user/restii_qr_generator/frontend/node_modules/@react-pdf/layout/lib/text/emoji.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nexports.__esModule = true;\nexports.fetchEmojis = exports.embedEmojis = exports.default = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _emojiRegex = _interopRequireDefault(require(\"emoji-regex\"));\n\nvar _image = _interopRequireDefault(require(\"@react-pdf/image\"));\n\n/* eslint-disable no-cond-assign */\n// Caches emoji images data\nvar emojis = {};\nvar regex = (0, _emojiRegex.default)();\n\nvar reflect = function reflect(promise) {\n  return function () {\n    return promise.apply(void 0, arguments).then(function (v) {\n      return v;\n    }, function (e) {\n      return e;\n    });\n  };\n}; // Returns a function to be able to mock resolveImage.\n\n\nvar makeFetchEmojiImage = function makeFetchEmojiImage() {\n  return reflect(_image.default);\n};\n/**\n * When an emoji as no color, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('‚ù§Ô∏è') => [\"‚ù§\", \"Ô∏è\"]\n *   (w/ color) Array.from('üëçüèø') => [\"üëç\", \"üèø\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\n\n\nvar _removeNoColor = function _removeNoColor(x) {\n  return x !== 'Ô∏è';\n};\n\nvar getCodePoints = function getCodePoints(string) {\n  return Array.from(string).filter(_removeNoColor).map(function (char) {\n    return char.codePointAt(0).toString(16);\n  }).join('-');\n};\n\nvar buildEmojiUrl = function buildEmojiUrl(emoji, source) {\n  var url = source.url,\n      format = source.format;\n  return \"\" + url + getCodePoints(emoji) + \".\" + format;\n};\n\nvar fetchEmojis = function fetchEmojis(string, source) {\n  if (!source || !source.url) return [];\n  var promises = [];\n  var match;\n\n  var _loop = function _loop() {\n    var emoji = match[0];\n\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      var emojiUrl = buildEmojiUrl(emoji, source);\n      emojis[emoji] = {\n        loading: true\n      };\n      var fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(fetchEmojiImage({\n        uri: emojiUrl\n      }).then(function (image) {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  };\n\n  while (match = regex.exec(string)) {\n    _loop();\n  }\n\n  return promises;\n};\n\nexports.fetchEmojis = fetchEmojis;\n\nvar embedEmojis = function embedEmojis(fragments) {\n  var result = [];\n\n  for (var i = 0; i < fragments.length; i += 1) {\n    var fragment = fragments[i];\n    var match = void 0;\n    var lastIndex = 0;\n\n    while (match = regex.exec(fragment.string)) {\n      var _match = match,\n          index = _match.index;\n      var emoji = match[0];\n      var emojiSize = fragment.attributes.fontSize;\n      var chunk = fragment.string.slice(lastIndex, index + match[0].length); // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: (0, _extends2.default)({}, fragment.attributes, {\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          })\n        });\n      } else {\n        // If no emoji data, we just replace the emoji with a nodef char\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0)),\n          attributes: fragment.attributes\n        });\n      }\n\n      lastIndex = index + emoji.length;\n    }\n\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n\n  return result;\n};\n\nexports.embedEmojis = embedEmojis;\nvar _default = fetchEmojis;\nexports.default = _default;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\nexports.__esModule = true;\nexports.default = void 0;\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\n// TODO: Implement using only matrices to support skew and even more operations than css.\nvar applySingleTransformation = function applySingleTransformation(ctx, transform, origin) {\n  var operation = transform.operation,\n    value = transform.value;\n  switch (operation) {\n    case 'scale':\n      {\n        var scaleX = value[0],\n          scaleY = value[1];\n        ctx.scale(scaleX, scaleY, {\n          origin: origin\n        });\n        break;\n      }\n    case 'rotate':\n      {\n        var angle = value[0];\n        ctx.rotate(angle, {\n          origin: origin\n        });\n        break;\n      }\n    case 'translate':\n      {\n        var x = value[0],\n          y = value[1];\n        ctx.translate(x, y, {\n          origin: origin\n        });\n        break;\n      }\n    case 'matrix':\n      {\n        ctx.transform.apply(ctx, value);\n        break;\n      }\n    default:\n      {\n        console.error(\"Transform operation: '\" + operation + \"' doesn't supported\");\n      }\n  }\n};\nvar applyTransformations = function applyTransformations(ctx, node) {\n  var _node$style, _node$props;\n  if (!node.origin) return node;\n  var origin = [node.origin.left, node.origin.top];\n  var operations = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.transform) || ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.transform) || [];\n  operations.forEach(function (operation) {\n    applySingleTransformation(ctx, operation, origin);\n  });\n  return node;\n};\nvar _default = R.curryN(2, applyTransformations);\nexports.default = _default;","map":{"version":3,"names":["_interopRequireWildcard","require","default","exports","__esModule","R","applySingleTransformation","ctx","transform","origin","operation","value","scaleX","scaleY","scale","angle","rotate","x","y","translate","apply","console","error","applyTransformations","node","_node$style","_node$props","left","top","operations","style","props","forEach","_default","curryN"],"sources":["C:/Users/user/restii_qr_generator/frontend/node_modules/@react-pdf/render/lib/operations/transform.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\n// TODO: Implement using only matrices to support skew and even more operations than css.\nvar applySingleTransformation = function applySingleTransformation(ctx, transform, origin) {\n  var operation = transform.operation,\n      value = transform.value;\n\n  switch (operation) {\n    case 'scale':\n      {\n        var scaleX = value[0],\n            scaleY = value[1];\n        ctx.scale(scaleX, scaleY, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'rotate':\n      {\n        var angle = value[0];\n        ctx.rotate(angle, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'translate':\n      {\n        var x = value[0],\n            y = value[1];\n        ctx.translate(x, y, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'matrix':\n      {\n        ctx.transform.apply(ctx, value);\n        break;\n      }\n\n    default:\n      {\n        console.error(\"Transform operation: '\" + operation + \"' doesn't supported\");\n      }\n  }\n};\n\nvar applyTransformations = function applyTransformations(ctx, node) {\n  var _node$style, _node$props;\n\n  if (!node.origin) return node;\n  var origin = [node.origin.left, node.origin.top];\n  var operations = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.transform) || ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.transform) || [];\n  operations.forEach(function (operation) {\n    applySingleTransformation(ctx, operation, origin);\n  });\n  return node;\n};\n\nvar _default = R.curryN(2, applyTransformations);\n\nexports.default = _default;"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,uBAAuB,GAAGC,OAAO,CAAC,+CAA+C,CAAC,CAACC,OAAO;AAE9FC,OAAO,CAACC,UAAU,GAAG,IAAI;AACzBD,OAAO,CAACD,OAAO,GAAG,KAAK,CAAC;AAExB,IAAIG,CAAC,GAAGL,uBAAuB,CAACC,OAAO,CAAC,OAAO,CAAC,CAAC;;AAEjD;AACA,IAAIK,yBAAyB,GAAG,SAASA,yBAAyBA,CAACC,GAAG,EAAEC,SAAS,EAAEC,MAAM,EAAE;EACzF,IAAIC,SAAS,GAAGF,SAAS,CAACE,SAAS;IAC/BC,KAAK,GAAGH,SAAS,CAACG,KAAK;EAE3B,QAAQD,SAAS;IACf,KAAK,OAAO;MACV;QACE,IAAIE,MAAM,GAAGD,KAAK,CAAC,CAAC,CAAC;UACjBE,MAAM,GAAGF,KAAK,CAAC,CAAC,CAAC;QACrBJ,GAAG,CAACO,KAAK,CAACF,MAAM,EAAEC,MAAM,EAAE;UACxBJ,MAAM,EAAEA;QACV,CAAC,CAAC;QACF;MACF;IAEF,KAAK,QAAQ;MACX;QACE,IAAIM,KAAK,GAAGJ,KAAK,CAAC,CAAC,CAAC;QACpBJ,GAAG,CAACS,MAAM,CAACD,KAAK,EAAE;UAChBN,MAAM,EAAEA;QACV,CAAC,CAAC;QACF;MACF;IAEF,KAAK,WAAW;MACd;QACE,IAAIQ,CAAC,GAAGN,KAAK,CAAC,CAAC,CAAC;UACZO,CAAC,GAAGP,KAAK,CAAC,CAAC,CAAC;QAChBJ,GAAG,CAACY,SAAS,CAACF,CAAC,EAAEC,CAAC,EAAE;UAClBT,MAAM,EAAEA;QACV,CAAC,CAAC;QACF;MACF;IAEF,KAAK,QAAQ;MACX;QACEF,GAAG,CAACC,SAAS,CAACY,KAAK,CAACb,GAAG,EAAEI,KAAK,CAAC;QAC/B;MACF;IAEF;MACE;QACEU,OAAO,CAACC,KAAK,CAAC,wBAAwB,GAAGZ,SAAS,GAAG,qBAAqB,CAAC;MAC7E;EACJ;AACF,CAAC;AAED,IAAIa,oBAAoB,GAAG,SAASA,oBAAoBA,CAAChB,GAAG,EAAEiB,IAAI,EAAE;EAClE,IAAIC,WAAW,EAAEC,WAAW;EAE5B,IAAI,CAACF,IAAI,CAACf,MAAM,EAAE,OAAOe,IAAI;EAC7B,IAAIf,MAAM,GAAG,CAACe,IAAI,CAACf,MAAM,CAACkB,IAAI,EAAEH,IAAI,CAACf,MAAM,CAACmB,GAAG,CAAC;EAChD,IAAIC,UAAU,GAAG,CAAC,CAACJ,WAAW,GAAGD,IAAI,CAACM,KAAK,MAAM,IAAI,IAAIL,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACjB,SAAS,MAAM,CAACkB,WAAW,GAAGF,IAAI,CAACO,KAAK,MAAM,IAAI,IAAIL,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,WAAW,CAAClB,SAAS,CAAC,IAAI,EAAE;EAC3NqB,UAAU,CAACG,OAAO,CAAC,UAAUtB,SAAS,EAAE;IACtCJ,yBAAyB,CAACC,GAAG,EAAEG,SAAS,EAAED,MAAM,CAAC;EACnD,CAAC,CAAC;EACF,OAAOe,IAAI;AACb,CAAC;AAED,IAAIS,QAAQ,GAAG5B,CAAC,CAAC6B,MAAM,CAAC,CAAC,EAAEX,oBAAoB,CAAC;AAEhDpB,OAAO,CAACD,OAAO,GAAG+B,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"script"}